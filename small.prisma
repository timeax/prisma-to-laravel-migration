datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL")
}
// Owner: User (alias method as "avatar")
/// @morph(name: imageable, type: one, model: Image, raw:"latest()", as: avatar)
model User {
  id        Int      @id @default(autoincrement())
  name      String
  email     String   @unique
  createdAt DateTime @default(now())
}

// Child: Image → auto morphTo('imageable')
model Image {
  id               Int     @id @default(autoincrement())
  path             String
  imageable_id     Int
  imageable_type   String
  createdAt        DateTime @default(now())
}

// Owners: Post, Video → morphToMany(Tag::class, 'taggable', 'taggables')
/// @morph(name: taggable, type: to many, model: Tag, table: "taggables")
model Post {
  id    Int    @id @default(autoincrement())
  title String
}

/// @morph(name: taggable, type: to many, model: Tag, table: "taggables")
model Video {
  id    Int    @id @default(autoincrement())
  title String
  url   String
}

// Inverse owner: Tag → morphedByMany(Post|Video, 'taggable', 'taggables')
/// @morph(name: taggable, type: by many, model: Post, table: "taggables")
/// @morph(name: taggable, type: by many, model: Video, table: "taggables")
model Tag {
  id   Int    @id @default(autoincrement())
  name String @unique
  taggable Taggable[] /// @local
}

// Pivot table (Prisma can't express the polymorphic side as relations; that's fine for the generator)
///@with(tag_id)
model Taggable {
  id             Int    @id @default(autoincrement())
  tag_id         Int
  taggable_id    Int
  taggable_type  String ///@with

  // Normal FK to Tag for integrity
  tag Tag @relation(fields: [tag_id], references: [id])

  @@index([taggable_type, taggable_id])
  @@map("taggables")
}