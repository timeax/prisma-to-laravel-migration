# Index 

Included Source Files (5)
- [src/generator/ts/directives.ts](#1)
- [src/generator/ts/generator.ts](#2)
- [src/generator/ts/index.ts](#3)
- [src/generator/ts/printer.ts](#4)
- [src/generator/ts/types.ts](#5)

---
---
#### 1


` File: src/generator/ts/directives.ts`  [↑ Back to top](#index)

```ts
// generator/ts/directives.ts
import type { DMMF } from "@prisma/generator-helper";

export interface TypeDirective {
   import?: string;
   type: string;
}

/**
 * Single entry in `@appends(...)`
 * - `name` is the append key
 * - `type` is optional; if omitted, TS generator can treat it as `any` or skip.
 */
export interface AppendEntry {
   name: string;
   type?: string;
}

/**
 * Parsed `@appends(...)` directive.
 */
export interface AppendsDirective {
   entries: AppendEntry[];
}

/**
 * Parse a `@type{ import: 'foo', type: 'Bar' }` directive
 * from a documentation string.
 *
 * Works for both **field-level** and **model-level** docs.
 */
export function parseTypeDirective(doc?: string | null): TypeDirective | undefined {
   if (!doc) return undefined;

   const m = doc.match(
      /@type\{\s*(?:import\s*:\s*'([^']+)')?\s*,?\s*type\s*:\s*'([^']+)'\s*\}/
   );

   return m
      ? {
         import: m[1] || undefined,
         type: m[2],
      }
      : undefined;
}

/**
 * Parse `@appends` from model-level documentation.
 *
 * Supports:
 * - @appends(foo, bar)
 * - @appends(foo:string, bar:Record<string, any>)
 * - @appends{ foo, bar }
 * - @appends{ foo:string, bar:number }
 *
 * We keep the syntax forgiving:
 *  - parentheses () or braces {} are both allowed
 *  - entries separated by comma
 *  - each entry is `name` or `name:type`
 */
export function parseAppendsDirective(doc?: string | null): AppendsDirective | undefined {
   if (!doc) return undefined;

   // Find the first "@appends..." occurrence
   const m = doc.match(/@appends\s*(\{[^}]*\}|\([^)]*\)|[^\r\n]*)/);
   if (!m) return undefined;

   let body = m[1].trim();

   // Strip surrounding {} or ()
   if ((body.startsWith("{") && body.endsWith("}")) || (body.startsWith("(") && body.endsWith(")"))) {
      body = body.slice(1, -1).trim();
   }

   if (!body) return undefined;

   const entries: AppendEntry[] = [];

   // Split by commas at top-level (no need for deep parsing here)
   for (const raw of body.split(",")) {
      const token = raw.trim();
      if (!token) continue;

      // Support "name" or "name:type"
      const [nameRaw, typeRaw] = token.split(":").map((s) => s.trim());
      if (!nameRaw) continue;

      const name = nameRaw;
      const type = typeRaw && typeRaw.length ? typeRaw : undefined;

      entries.push({ name, type });
   }

   if (!entries.length) return undefined;
   return { entries };
}

/**
 * Convenience helpers to get directives directly from DMMF.
 */
export function getModelTypeDirective(model: DMMF.Model): TypeDirective | undefined {
   return parseTypeDirective(model.documentation);
}

export function getFieldTypeDirective(field: DMMF.Field): TypeDirective | undefined {
   return parseTypeDirective(field.documentation);
}

export function getModelAppendsDirective(model: DMMF.Model): AppendsDirective | undefined {
   return parseAppendsDirective(model.documentation);
}
```

---
#### 2


` File: src/generator/ts/generator.ts`  [↑ Back to top](#index)

```ts
// generator/ts/generator.ts
import type { DMMF } from "@prisma/generator-helper";
import type { TypesConfig } from "./index.js";
import {
   TsEnumDefinition,
   TsModelDefinition,
   TsModelField,
   TsAppendProperty,
   TsImport,
} from "./types.js";
import {
   getFieldTypeDirective,
   getModelTypeDirective,
   getModelAppendsDirective,
} from "./directives.js";
import { listFrom, stripDirectives } from "../../utils/utils.js";

export class PrismaToTypesGenerator {
   constructor(
      private readonly dmmf: DMMF.Document,
      private readonly cfg: TypesConfig
   ) { }

   generateAll(): { models: TsModelDefinition[]; enums: TsEnumDefinition[] } {
      const models = this.dmmf.datamodel.models.map((model) =>
         this.buildModelDefinition(model)
      );

      const enums = this.dmmf.datamodel.enums.map(
         (e): TsEnumDefinition => ({
            name: e.name,
            values: e.values.map((v) => v.name),
            doc: e.documentation ?? "",
         })
      );

      return { models, enums };
   }

   /**
    * Where should models import enums from?
    *
    * You can add `enumImportFrom?: string` to TypesConfig; if not set,
    * we default to "./enums".
    */
   private getEnumImportFrom(): string {
      const anyCfg = this.cfg as TypesConfig & {
         enumImportFrom?: string;
      };
      return anyCfg.enumImportFrom ?? "./enums";
   }

   /**
    * Quick check for a @with directive on a relation field.
    * If present, we treat the relation as "eager" and keep it required.
    */
   private hasWithDirective(field: DMMF.Field): boolean {
      if (!field.documentation) return false;
      // very small heuristic; you can tighten this later in directives.ts
      return /@with\b/.test(field.documentation);
   }

   /**
    * Detect morph child pairs on a model:
    *   <base>_id   +   <base>_type
    *
    * Returns the list of `base` names, e.g. ["commentable", "imageable"].
    * This matches the polymorphic rules in the README:
    * child-side `morphTo` is auto-detected from scalar pairs.
    */
   private getMorphBases(model: DMMF.Model): string[] {
      const hasId: Set<string> = new Set();
      const hasType: Set<string> = new Set();

      for (const field of model.fields) {
         if (field.kind !== "scalar") continue;

         if (field.name.endsWith("_id")) {
            const base = field.name.slice(0, -3); // remove "_id"
            if (base) hasId.add(base);
         } else if (field.name.endsWith("_type")) {
            const base = field.name.slice(0, -5); // remove "_type"
            if (base) hasType.add(base);
         }
      }

      const bases: string[] = [];
      for (const base of hasId) {
         if (hasType.has(base)) {
            bases.push(base);
         }
      }
      return bases;
   }

   private buildModelDefinition(model: DMMF.Model): TsModelDefinition {
      const importsMap = new Map<string, Set<string>>();
      const enumNames = new Set<string>(); // enums used by this model

      const containsWith = (name: string) =>
         listFrom(model.documentation ?? "", "with").includes(name);

      // Model-level @hidden{fieldA,fieldB}
      const hiddenFromModel = new Set(
         listFrom(model.documentation ?? "", "hidden")
            .map((n) => n.trim())
            .filter(Boolean)
      );

      // 1) Field-level definitions
      const fields: TsModelField[] = model.fields.map((field) => {
         const doc = field.documentation ?? "";

         // base inferred type (from prisma)
         let tsType = this.mapPrismaTypeToTs(field);

         // field-level @type override
         const typeDirective = getFieldTypeDirective(field);
         if (typeDirective) {
            tsType = typeDirective.type;

            if (typeDirective.import) {
               const existing =
                  importsMap.get(typeDirective.import) ?? new Set<string>();
               existing.add(typeDirective.type);
               importsMap.set(typeDirective.import, existing);
            }
         } else {
            // No @type override → if this is an enum, remember it
            if (field.kind === "enum") {
               // field.type is the enum name (e.g. "UserStatus")
               enumNames.add(field.type);
            }
         }

         const isRelation = field.kind === "object";
         const hasWith =
            isRelation && (this.hasWithDirective(field) || containsWith(field.name));

         // ---- @hidden detection ------------------------------------
         // 1) field-level: "/// @hidden" or "/// @hidden{...}"
         const hiddenInline =
            /(^|\s)@hidden(\b|[{(])/m.test(doc) ||
            listFrom(doc, "hidden").includes(field.name);

         // 2) model-level list
         const hiddenByModel = hiddenFromModel.has(field.name);

         const isHidden = hiddenInline || hiddenByModel;

         return {
            name: field.name,
            type: tsType,
            // Relations: optional by default (navigation props),
            // unless @with says "this is always loaded".
            // Non-relations: keep Prisma's required flag semantics.
            optional: isRelation ? !hasWith : !field.isRequired,
            isList: field.isList,
            isId: field.isId,
            isGenerated: !!field.isGenerated,
            isUpdatedAt: !!field.isUpdatedAt,
            // used by the TS printer to drop @hidden from the public shape
            hidden: isHidden,
         } as TsModelField;
      });

      // 2) Model-level @type for extra imports (does not define fields)
      const modelTypeDirective = getModelTypeDirective(model);
      if (modelTypeDirective && modelTypeDirective.import) {
         const existing =
            importsMap.get(modelTypeDirective.import) ?? new Set<string>();
         existing.add(modelTypeDirective.type);
         importsMap.set(modelTypeDirective.import, existing);
      }

      // 3) Model-level @appends(...) → extra computed properties
      const appendsDirective = getModelAppendsDirective(model);
      const appends: TsAppendProperty[] = [];

      if (appendsDirective) {
         for (const entry of appendsDirective.entries) {
            appends.push({
               name: entry.name,
               // If a type is provided, use it; otherwise fallback to `any`
               type: entry.type ?? "any",
            });
         }
      }

      // 4) Morph child pairs → auto-append relation-like properties
      //
      // For each detected base (e.g. "commentable" from commentable_id + commentable_type),
      // we add an appended TS property:
      //
      //    commentable?: any
      //
      // unless the user already declared it via @appends{commentable: ...}.
      const morphBases = this.getMorphBases(model);

      if (morphBases.length > 0) {
         const existingNames = new Set(appends.map((a) => a.name));
         for (const base of morphBases) {
            if (existingNames.has(base)) continue; // don't clobber typed @appends
            appends.push({
               name: base,
               type: "any",
            });
         }
      }

      // 5) Enums used by this model → import from enums file
      if (enumNames.size > 0) {
         const enumFrom = this.getEnumImportFrom();
         const existing = importsMap.get(enumFrom) ?? new Set<string>();

         for (const enumName of enumNames) {
            existing.add(enumName);
         }

         importsMap.set(enumFrom, existing);
      }

      // 6) Normalize imports
      const imports: TsImport[] = Array.from(importsMap.entries()).map(
         ([from, types]) => ({
            from,
            types: Array.from(types).sort(),
         })
      );

      return {
         name: model.name,
         fields,
         appends,
         imports,
         // strip directives from doc so TS header comment stays clean
         doc: stripDirectives(model.documentation),
      };
   }

   /**
    * Prisma → TS mapping, overridable via @type.
    *
    * - Scalars → TS primitives (you can later swap to cfg.scalarMap).
    * - Enums   → enum name (imported via enums file).
    * - Objects → related model name (relation), with list handling.
    */
   private mapPrismaTypeToTs(field: DMMF.Field): string {
      const readonlyArrays = !!(this.cfg as any).readonlyArrays;

      const wrapList = (base: string) =>
         field.isList
            ? readonlyArrays
               ? `ReadonlyArray<${base}>`
               : `${base}[]`
            : base;

      // Scalar fields
      if (field.kind === "scalar") {
         let base: string;
         switch (field.type) {
            case "Int":
            case "BigInt":
            case "Float":
            case "Decimal":
               base = "number";
               break;
            case "Boolean":
               base = "boolean";
               break;
            case "String":
               base = "string";
               break;
            case "DateTime":
               base = "string"; // you can later map to Date via scalarMap
               break;
            case "Json":
               base = "string"; // or unknown / Record<string,any> via scalarMap
               break;
            default:
               base = "any";
         }
         return wrapList(base);
      }

      // Enums → use enum name directly (imported via getEnumImportFrom)
      if (field.kind === "enum") {
         return wrapList(field.type as string);
      }

      // Relations (object) → use related model name
      // (interface names == Prisma model names for now)
      if (field.kind === "object") {
         const base = field.type as string; // related model name
         return wrapList(base);
      }

      // Fallback
      return wrapList("any");
   }
}
```

---
#### 3


` File: src/generator/ts/index.ts`  [↑ Back to top](#index)

```ts
// generator/ts/index.ts
import type {
   GeneratorOptions,
   GeneratorConfig,
} from "@prisma/generator-helper";
import path from "node:path";
import { existsSync, mkdirSync } from "node:fs";

import { loadSharedConfig } from "../../utils/loadSharedCfg.js";
import type {
   TypesConfigOverride,
   StubGroupConfig,
} from "types/laravel-config.js";

import { PrismaToTypesGenerator } from "./generator.js";
import type { TsModelDefinition, TsEnumDefinition } from "./types.js";
import { TsPrinter } from "./printer.js";
import { writeWithMerge } from "../../diff-writer/writer.js";
import { resolveStub } from "../../utils/utils.js";

/**
 * TS generator config:
 * - everything from TypesConfigOverride, except we own `stubDir` + `groups`
 */
export interface TypesConfig
   extends Omit<TypesConfigOverride, "groups" | "stubDir"> {
   stubDir: string;
   groups: StubGroupConfig[];
}

/** default TS output folder if not overridden */
function getDefaultTsOutDir(generator: GeneratorConfig | undefined): string {
   return generator?.output?.value ?? "resources/ts/prisma";
}

/**
 * Helper: does this model have a model-specific TS stub?
 *
 * Mirrors TsPrinter.hasModelSpecificStub:
 *  - use resolveStub(stubCfg, "ts", key)
 *  - treat index.stub as module-level, not model-specific
 */
function hasModelSpecificTsStub(
   model: TsModelDefinition,
   cfg: TypesConfig,
): boolean {
   if (!cfg.stubDir) return false;

   const key =
      (model as any).tableName && typeof (model as any).tableName === "string"
         ? (model as any).tableName
         : model.name;

   const stubConfig = {
      stubDir: cfg.stubDir,
      groups: cfg.groups,
      tablePrefix: cfg.tablePrefix,
      tableSuffix: cfg.tableSuffix,
      namespace: cfg.namespace,
   };

   const stubPath = resolveStub(stubConfig as any, "ts", key);
   if (!stubPath) return false;

   return path.basename(stubPath) !== "index.stub";
}

export async function generateTypesFromPrisma(options: GeneratorOptions) {
   const { dmmf, generator } = options;

   // 0) Pull config values from generator block
   const raw = (generator.config ?? {}) as Record<string, string | undefined>;

   // Load shared config (auto-discovers prisma/laravel.config.js from schema dir)
   const schemaDir = path.dirname(options.schemaPath);
   const shared = await loadSharedConfig(schemaDir);

   // --- 1. Load stub groups if present (same pattern as modeler) ------
   let groups: StubGroupConfig[] = [];
   if (raw["groups"]) {
      const groupsModulePath = path.resolve(process.cwd(), raw["groups"]);
      const importedModule = await import(groupsModulePath);
      const imported = importedModule.default ?? importedModule;

      if (!Array.isArray(imported)) {
         throw new Error(
            `Custom groups module must export an array, but got ${typeof imported}`,
         );
      }
      groups = imported;
   }

   // --- 2. Helper to pick config values in precedence order ----------
   const pick = <K extends keyof TypesConfigOverride>(
      key: K,
      fallback?: any,
   ): any | undefined =>
      // shared.ts section (if present)
      (shared.ts as any)?.[key] ??
      // shared root (if you keep ts props there)
      (shared as any)[key] ??
      // generator block config
      raw[key as string] ??
      // explicit fallback
      fallback;

   // --- 3. Build merged TS generator config --------------------------
   const cfg: TypesConfig = {
      // Laravel-ish generator knobs
      overwriteExisting: pick("overwriteExisting", true),
      prettier: pick("prettier", false),
      noEmit: pick("noEmit", false),

      tablePrefix: pick("tablePrefix", ""),
      tableSuffix: pick("tableSuffix", ""),
      namespace: pick("namespace", "App"),

      // stubDir & groups for TS (same structure as PHP generators)
      stubDir:
         pick("stubDir") ??
         shared.stubDir ??
         path.join(schemaDir, "stubs"),
      groups,

      // TS-specific
      outputDir: pick("outputDir") ?? getDefaultTsOutDir(generator),

      // enums-only knobs
      declaration: pick("declaration", false),
      noEmitEnums: pick("noEmitEnums", false),

      shape: pick("shape", "interface"),
      scalarMap: pick("scalarMap"),
      nullableAsOptional: pick("nullableAsOptional", false),
      readonlyArrays: pick("readonlyArrays", false),
      namePrefix: pick("namePrefix", ""),
      nameSuffix: pick("nameSuffix", ""),
      moduleName: pick("moduleName", "database/prisma"),
      modelsFileName: pick("modelsFileName", "index"),
      enumsFileName: pick("enumsFileName", "enums"),
   };

   // --- 4. Ensure TS output directory exists -------------------------
   const tsOutDir = path.resolve(process.cwd(), cfg.outputDir!);
   if (!existsSync(tsOutDir)) {
      mkdirSync(tsOutDir, { recursive: true });
   }

   // Tell diff-writer how to pretty-print TS (if enabled)
   (global as any)._config = (global as any)._config || {};
   (global as any)._config.ts = {
      prettier: !!cfg.prettier,
   };

   // --- 5. Use DMMF from GeneratorOptions (no merging bullshit) ------
   const tsGen = new PrismaToTypesGenerator(dmmf, cfg as any);
   const {
      models,
      enums,
   }: {
      models: TsModelDefinition[];
      enums: TsEnumDefinition[];
   } = tsGen.generateAll();

   if (cfg.noEmit) {
      // useful for tests or "dry" runs
      return { models, enums, config: cfg };
   }

   // --- 6. Create TS printer (handles stubs + moduleName) ------------
   const stubConfig = {
      stubDir: cfg.stubDir,
      groups: cfg.groups,
      tablePrefix: cfg.tablePrefix,
      tableSuffix: cfg.tableSuffix,
      namespace: cfg.namespace,
   };

   const printer = new TsPrinter({
      stubConfig,
      moduleName: cfg.moduleName,
      shape: cfg.shape,
   });

   // Extensions:
   // - models are ALWAYS .d.ts
   // - enums honour cfg.declaration
   const modelExt = ".d.ts";
   const enumExt = cfg.declaration ? ".d.ts" : ".ts";

   // --- 7. Emit enums (single file, no TS stubs) ---------------------
   if (!cfg.noEmitEnums && enums.length) {
      const enumsCode = printer.printEnums(enums);
      if (enumsCode.trim()) {
         const enumsBase = cfg.enumsFileName || "enums";
         const enumsPath = path.join(tsOutDir, `${enumsBase}${enumExt}`);
         await writeWithMerge(
            enumsPath,
            enumsCode,
            "ts",
            cfg.overwriteExisting,
         );
      }
   }
   // --- 8. Emit models -----------------------------------------------
   //
   // TsPrinter.printModels(models) returns:
   //   [0] => main module file (all non-stubbed models, plus module-level stub)
   //   [1..] => one output per model that has a dedicated TS stub
   //
   // We map those [1..] outputs to the corresponding models (in order)
   // whose stub resolves to a non-index TS stub, and emit them as
   // separate files using the decorated model name.
   const modelOutputs = printer.printModels(models);
   const [mainFile, ...specialOutputs] = modelOutputs;

   // Determine which models are "special" (have per-model TS stub)
   const specialModels = models.filter((m) =>
      hasModelSpecificTsStub(m, cfg),
   );

   if (specialOutputs.length !== specialModels.length) {
      // Not fatal, but worth logging in case of mismatch.
      console.warn(
         `[ts-generator] Mismatch between stubbed model count (${specialModels.length}) and special outputs (${specialOutputs.length}).`,
      );
   }

   // 8a) Main combined file: all non-stubbed models
   if (mainFile.trim()) {
      const mainPath = path.join(
         tsOutDir,
         `${cfg.modelsFileName ?? "index"}${modelExt}`,
      );
      await writeWithMerge(
         mainPath,
         mainFile,
         "ts",
         cfg.overwriteExisting,
      );
   }

   // 8b) Per-model stubbed outputs (always .d.ts)
   specialOutputs.forEach(async (code, idx) => {
      const model = specialModels[idx];
      if (!model) return;

      const decoratedName = `${cfg.namePrefix ?? ""}${model.name}${cfg.nameSuffix ?? ""
         }`;
      const filePath = path.join(
         tsOutDir,
         `${decoratedName}${modelExt}`,
      );

      await writeWithMerge(
         filePath,
         code,
         "ts",
         cfg.overwriteExisting,
      );
   });

   return { models, enums, config: cfg };
}
```

---
#### 4


` File: src/generator/ts/printer.ts`  [↑ Back to top](#index)

```ts
// generator/ts/printer.ts
// noinspection JSUnusedGlobalSymbols

import fs from "node:fs";
import path from "node:path";
import type { TsModelDefinition, TsEnumDefinition, TsImport } from "./types.js";
import { resolveStub, type StubConfig, formatStub, getStubPath } from "../../utils/utils.js";

/**
 * Options for the TS printer.
 *
 * - `stubConfig` is the same config object used by the PHP generators;
 *   we reuse it and call `resolveStub(cfg, 'ts', <key>)`.
 * - `moduleName` can be overridden via TypesConfigOverride.moduleName.
 */
export interface TsPrinterOptions {
   /**
    * Stub configuration (same structure as Laravel generators).
    *
    * We expect at least:
    *   { stubDir: string; groups?: FlexibleStubGroup[] }
    */
   stubConfig?: StubConfig;

   /**
    * Optional module name used for `declare module "…" { ... }`.
    * If omitted, we default to "database/prisma".
    */
   moduleName?: string;

   /**
    * Use `interface` or `type` for model declarations.
    * (You already exposed this on TypesConfigOverride.shape.)
    *
    * Default: "interface".
    */
   shape?: "interface" | "type";
}

/**
 * Very small rendering context for a single model.
 */
export interface TsModelContext {
   name: string;
   tableName?: string;
   imports: string;
   body: string; // inner shape body (properties only, already indented)
   headerComment?: string;
}

/**
 * Very small rendering context for enums.
 */
export interface TsEnumContext {
   name: string;
   imports: string;
   headerComment?: string;
   body: string; // enum declaration
}

type ModelStubFn = (
   model: TsModelDefinition,
   imports: string,
   content: string,
   body: string,
   moduleName: string
) => string;

type ModuleStubFn = (
   imports: string,
   content: string,
   body: string,
   moduleName: string,
   models: TsModelDefinition[]
) => string;

/**
 * Printer responsible for turning our TS model/enum definitions
 * into actual `.ts` source code, with TS stubs in the same spirit
 * as the PHP `StubModelPrinter`.
 *
 * Behaviour:
 * - Models:
 *    - `printModels(models)` returns string[]:
 *        [0] => main file with all "non-stubbed" models
 *        [1..] => per-model outputs for models that *do* have TS stubs
 *    - The main file is optionally wrapped in `declare module "…"`.
 *    - A module-level TS stub (index stub) can further wrap/augment it and
 *      receives:
 *         imports  → merged imports for non-stub models
 *         content  → interfaces/types only
 *         body     → declare-module-wrapped content
 *         models   → all model definitions (for advanced use)
 *
 * - Enums:
 *    - `printEnums(enums)` returns a single string with all enum declarations.
 *    - Enums **do not** use TS stubs; they are always printed directly.
 */
export class TsPrinter {
   private readonly stubConfig?: StubConfig;
   private readonly moduleName: string;
   private readonly shape: "interface" | "type";

   // cache: module-level stub
   #currentModuleStub = "";
   private moduleTmpl?: ModuleStubFn;

   // cache: per-model stub → template function
   private modelStubCache = new Map<string, ModelStubFn>();

   constructor(options: TsPrinterOptions = {}) {
      this.stubConfig = options.stubConfig;
      this.moduleName = options.moduleName || "database/prisma";
      this.shape = options.shape ?? "interface";
   }

   // ---------------------------------------------------------------------------
   // PUBLIC API
   // ---------------------------------------------------------------------------

   /**
    * Print *all* models.
    *
    * Returns:
    *   [0] - main file (all models without a dedicated TS stub)
    *   [1..] - one string per model that has a dedicated TS stub
    */
   public printModels(models: TsModelDefinition[]): string[] {
      const regularModelContexts: TsModelContext[] = [];
      const regularModelDefs: TsModelDefinition[] = [];

      const specialOutputs: string[] = [];

      for (const model of models) {
         const ctx = this.buildModelContext(model);
         const hasSpecialStub = this.hasModelSpecificStub(model);

         if (hasSpecialStub) {
            const singleContent = this.renderModelStandalone(ctx); // header + shape, no imports
            const body = this.wrapInModule(singleContent);
            const code = this.renderModelWithStub(model, ctx, singleContent, body);
            specialOutputs.push(code);
         } else {
            regularModelContexts.push(ctx);
            regularModelDefs.push(model);
         }
      }

      const importsBlock = this.collectImports(regularModelContexts);
      const interfacesContent = this.renderModelsBlock(regularModelContexts); // headers + shapes only
      const body = this.wrapInModule(interfacesContent);
      const mainFile = this.renderModuleWithStub(
         importsBlock,
         interfacesContent,
         body,
         models
      );

      return [mainFile, ...specialOutputs];
   }

   /**
    * Print all enums as a single string.
    *
    * Uses TS `enum` declarations by default.
    * No stubs here (by design).
    */
   public printEnums(enums: TsEnumDefinition[]): string {
      const chunks: string[] = [];

      for (const en of enums) {
         const ctx = this.buildEnumContext(en);
         const code = this.renderEnumStandalone(ctx);
         if (code.trim()) {
            chunks.push(code.trim());
         }
      }

      return chunks.join("\n\n") + (chunks.length ? "\n" : "");
   }

   // ---------------------------------------------------------------------------
   // CONTEXT BUILDERS
   // ---------------------------------------------------------------------------

   private buildModelContext(model: TsModelDefinition): TsModelContext {
      const headerComment = this.renderHeaderComment((model as any).doc);
      const imports = this.renderImports(model);
      const body = this.renderModelShape(model);

      return {
         name: model.name,
         tableName: (model as any).tableName,
         imports,
         body,
         headerComment,
      };
   }

   private buildEnumContext(en: TsEnumDefinition): TsEnumContext {
      const headerComment = this.renderHeaderComment((en as any).doc);
      const imports = this.renderImports(en as any);
      const body = this.renderEnumDeclaration(en);

      return {
         name: en.name,
         imports,
         headerComment,
         body,
      };
   }

   // ---------------------------------------------------------------------------
   // IMPORTS
   // ---------------------------------------------------------------------------

   private normalizeTsImports(imports: TsImport[]): TsImport[] {
      const grouped = new Map<string, Set<string>>();

      for (const imp of imports) {
         if (!imp.from) continue;

         const set = grouped.get(imp.from) ?? new Set<string>();
         for (const t of imp.types ?? []) {
            if (!t) continue;
            set.add(t);
         }
         grouped.set(imp.from, set);
      }

      return Array.from(grouped.entries())
         .map(([from, set]) => ({
            from,
            types: Array.from(set).sort(),
         }))
         .sort((a, b) => a.from.localeCompare(b.from));
   }
   /**
    * Render import statements for a node that has an `imports` property:
    *   node.imports?: { from: string; types: string[] }[];
    *
    * (If your actual shape differs, tweak here.)
    */
   private renderImports(node: { imports?: { from: string; types: string[] }[] }): string {
      const imports = node.imports ?? [];
      if (!imports.length) return "";

      return this.normalizeTsImports(imports)
         .map((i) => {
            const names = i.types.join(", ");
            return `import { ${names} } from ${JSON.stringify(i.from)};`;
         })
         .join("\n");
   }

   /**
   * Merge & dedupe imports from multiple model contexts.
   *
   * We re-parse the per-model import lines into TsImport objects so that
   * `normalizeTsImports` can group everything by `from` and merge type lists.
   */
   private collectImports(ctxs: TsModelContext[]): string {
      const collected: TsImport[] = [];

      // Very small parser for lines like: import { A, B } from "./enums";
      const importRe =
         /^import\s*\{\s*([^}]+)\}\s*from\s*(['"])([^'"]+)\2;?$/;

      for (const ctx of ctxs) {
         const raw = (ctx.imports || "").replace(/\r\n/g, "\n");
         if (!raw.trim()) continue;

         for (const line of raw.split("\n")) {
            const trimmed = line.trim();
            if (!trimmed) continue;

            const m = importRe.exec(trimmed);
            if (!m) {
               // If it's some other kind of import (`import "./x"`), just keep it as-is
               // by treating it as a TsImport with empty type list.
               if (trimmed.startsWith("import ")) {
                  collected.push({
                     from: trimmed,         // sentinel; will emit as-is below
                     types: [],             // no types
                  } as any);
               }
               continue;
            }

            const typeList = m[1]
               .split(",")
               .map((t) => t.trim())
               .filter(Boolean);
            const from = m[3];

            collected.push({ from, types: typeList });
         }
      }

      // Split “raw” imports (non `{ A } from "x"` style) from structured ones
      const rawLines = collected
         .filter((imp) => !imp.types?.length && imp.from.startsWith("import "))
         .map((imp) => imp.from);

      const structured = collected.filter(
         (imp) => imp.types && imp.types.length && !imp.from.startsWith("import "),
      );

      const normalized = this.normalizeTsImports(structured);

      const structuredLines = normalized.map(
         (i) => `import { ${i.types.join(", ")} } from ${JSON.stringify(i.from)};`,
      );

      // Deduplicate everything
      const allLines = Array.from(
         new Set([...rawLines, ...structuredLines]),
      );

      return allLines.join("\n");
   }
   // ---------------------------------------------------------------------------
   // MODEL RENDERING (DEFAULT)
   // ---------------------------------------------------------------------------

   /**
    * Render a *single* model in isolation (header + shape).
    *
    * NOTE: no imports here; imports are passed separately into stubs.
    */
   private renderModelStandalone(ctx: TsModelContext): string {
      const chunks: string[] = [];

      if (ctx.headerComment) {
         chunks.push(ctx.headerComment.trimEnd());
      }

      chunks.push(this.wrapShape(ctx.name, ctx.body));

      return chunks.join("\n\n") + "\n";
   }

   /**
    * Render a *block* of models (all non-stubbed) into one text chunk.
    * Again, this is header + shape only; imports are handled separately.
    */
   private renderModelsBlock(ctxs: TsModelContext[]): string {
      if (!ctxs.length) return "";

      const pieces = ctxs.map((ctx) => this.renderModelStandalone(ctx).trimEnd());
      return pieces.join("\n\n") + "\n";
   }

   private renderModelShape(model: TsModelDefinition): string {
      const props = (model as any).properties ?? (model as any).fields ?? [];

      const lines: string[] = [];

      for (const p of props) {
         const doc = p.doc ? this.renderHeaderComment(p.doc) + "\n" : "";
         const optional = p.optional ? "?" : "";
         lines.push(
            `${doc}${p.name}${optional}: ${p.type};`
         );
      }

      return indentBlock(lines.join("\n"));
   }

   private wrapShape(name: string, body: string): string {
      if (this.shape === "type") {
         // type alias
         return `export type ${name} = {\n${body}\n};`;
      }

      // interface
      return `export interface ${name} {\n${body}\n}`;
   }

   // ---------------------------------------------------------------------------
   // ENUM RENDERING (DEFAULT, NO STUBS)
   // ---------------------------------------------------------------------------
   private renderEnumDeclaration(en: TsEnumDefinition): string {
      const values = en.values ?? [];

      const lines: string[] = [];
      lines.push(`export enum ${en.name} {`);

      for (const memberName of values) {
         // We assume Prisma enum member names are valid identifiers.
         // Emit: Foo = "Foo",
         const stringLiteral = JSON.stringify(memberName);
         lines.push(`  ${memberName} = ${stringLiteral},`);
      }

      lines.push("}");

      return lines.join("\n");
   }

   private renderEnumStandalone(ctx: TsEnumContext): string {
      const parts: string[] = [];

      if (ctx.imports.trim()) {
         parts.push(ctx.imports.trimEnd());
      }

      if (ctx.headerComment) {
         parts.push(ctx.headerComment.trimEnd());
      }

      parts.push(ctx.body);

      return parts.join("\n\n") + "\n";
   }

   // ---------------------------------------------------------------------------
   // HEADER COMMENT
   // ---------------------------------------------------------------------------

   private renderHeaderComment(doc?: string | null): string | undefined {
      if (!doc) return undefined;

      const lines = doc.split(/\r?\n/).map((l) => l.trimEnd());
      if (!lines.length) return undefined;

      const body = lines.map((l) => (l ? ` * ${l}` : " *")).join("\n");
      return `/**\n${body}\n */`;
   }

   // ---------------------------------------------------------------------------
   // MODULE WRAPPING
   // ---------------------------------------------------------------------------

   /**
    * Wrap a piece of `content` in a `declare module "<moduleName>" { ... }`
    * block, if moduleName is present. Otherwise, just return content.
    *
    * This result is what we pass to module stubs as `body`.
    */
   private wrapInModule(content: string): string {
      const trimmed = content.trim();
      if (!trimmed) return "";

      const indented = indentBlock(trimmed);
      return `declare module ${JSON.stringify(this.moduleName)} {\n${indented}\n}\n`;
   }

   // ---------------------------------------------------------------------------
   // STUB HANDLING — MODELS
   // ---------------------------------------------------------------------------

   /**
    * Does this model have a *specific* TS stub?
    *
    * We treat `ts/index.stub` as the module-level stub, not as a per-model stub.
    * So "specific stub" means a resolved stub whose basename is **not** index.stub.
    */
   private hasModelSpecificStub(model: TsModelDefinition): boolean {
      if (!this.stubConfig?.stubDir) return false;

      const key = (model as any).tableName || model.name;
      const stubPath = resolveStub(this.stubConfig, "ts", key);
      if (!stubPath) return false;

      const base = path.basename(stubPath);
      return base !== "index.stub";
   }

   private renderModelWithStub(
      model: TsModelDefinition,
      ctx: TsModelContext,
      content: string,
      body: string,
   ): string {
      if (!this.stubConfig?.stubDir) {
         // No stub config at all → default: imports + body
         const parts = [];
         if (ctx.imports.trim()) parts.push(ctx.imports.trimEnd());
         if (body.trim()) parts.push(body.trimEnd());
         return parts.join("\n\n") + "\n";
      }

      const key = (model as any).tableName || model.name;
      const stubPath = resolveStub(this.stubConfig, "ts", key);
      if (!stubPath || path.basename(stubPath) === "index.stub") {
         // No specific stub (or only index) → default: imports + body
         const parts = [];
         if (ctx.imports.trim()) parts.push(ctx.imports.trimEnd());
         if (body.trim()) parts.push(body.trimEnd());
         return parts.join("\n\n") + "\n";
      }

      let tmpl = this.modelStubCache.get(stubPath);
      if (!tmpl) {
         const raw = fs.readFileSync(path.resolve(stubPath), "utf8").trim();
         tmpl = new Function(
            "model",
            "imports",
            "content",
            "body",
            "moduleName",
            `return \`${formatStub(raw)}\`;`,
         ) as ModelStubFn;
         this.modelStubCache.set(stubPath, tmpl);
      }

      const out = tmpl(
         model,
         ctx.imports || "",
         content,
         body,
         this.moduleName,
      );
      return out.replace(/\r\n/g, "\n");
   }

   // ---------------------------------------------------------------------------
   // STUB HANDLING — MODULE LEVEL
   // ---------------------------------------------------------------------------

   /**
    * Apply the module-level TS stub (typically `stubs/ts/index.stub`),
    * if present. The stub receives:
    *
    *   - `imports`: merged import block for non-stub models
    *   - `content`: raw interfaces/types only (no imports)
    *   - `body`: the same content wrapped in `declare module "…" { ... }`
    *   - `moduleName`: the configured module name (or default "database/prisma")
    *   - `models`: the *full* list of model definitions (in case the stub wants them)
    */
   private renderModuleWithStub(
      imports: string,
      content: string,
      body: string,
      models: TsModelDefinition[],
   ): string {
      const hasImports = imports.trim().length > 0;

      if (!this.stubConfig?.stubDir) {
         // No stub config → default: imports + body
         const parts = [];
         if (hasImports) parts.push(imports.trimEnd());
         if (body.trim()) parts.push(body.trimEnd());
         return parts.join("\n\n") + "\n";
      }

      // Resolve module-level stub via 'index' key.
      const stubPath = resolveStub(this.stubConfig, "ts", "index") ?? getStubPath('ts.stub');
      if (!stubPath) {
         // No module stub → default: imports + body
         const parts = [];
         if (hasImports) parts.push(imports.trimEnd());
         if (body.trim()) parts.push(body.trimEnd());
         return parts.join("\n\n") + "\n";
      }

      if (!this.moduleTmpl || stubPath !== this.#currentModuleStub) {
         const raw = fs.readFileSync(path.resolve(stubPath), "utf8").trim();
         this.moduleTmpl = new Function(
            "imports",
            "content",
            "body",
            "moduleName",
            "models",
            `return \`${formatStub(raw)}\`;`,
         ) as ModuleStubFn;
         this.#currentModuleStub = stubPath;
      }

      const tmpl = this.moduleTmpl!;
      const out = tmpl(
         imports || "",
         content,
         body,
         this.moduleName,
         models,
      );

      return out.replace(/\r\n/g, "\n");
   }
}

// ---------------------------------------------------------------------------
// Small helpers
// ---------------------------------------------------------------------------

function indentBlock(text: string, indent = "  "): string {
   const trimmed = text.replace(/\r\n/g, "\n");
   if (!trimmed.trim()) return "";
   return trimmed
      .split("\n")
      .map((line) => (line.length ? indent + line : line))
      .join("\n");
}
```

---
#### 5


` File: src/generator/ts/types.ts`  [↑ Back to top](#index)

```ts
// generator/ts/types.ts
export interface TsImport {
   from: string;
   types: string[]; // e.g. ['UserId', 'Email']
}

export interface TsModelField {
   name: string;
   type: string;
   optional: boolean;
   isList: boolean;
   isId?: boolean;
   isGenerated?: boolean;
   isUpdatedAt?: boolean;
   hidden?: boolean;
   // ...other flags
}

export interface TsAppendProperty {
   name: string;
   type: string; // resolved TS type, or 'any' if not specified
}

export interface TsModelDefinition {
   name: string;
   fields: TsModelField[];
   appends: TsAppendProperty[];
   imports: TsImport[];
   doc: string
}

export interface TsEnumDefinition {
   name: string;
   values: string[];
   doc: string
}
```


---
*Generated with [Prodex](https://github.com/emxhive/prodex) — Codebase decoded.*
<!-- PRODEx v1.4.5 | 2025-12-15T10:56:08.237Z -->